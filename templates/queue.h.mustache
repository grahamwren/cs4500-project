#pragma once

#include "../lib.h"

/**
 * {{name}}Queue: a FIFO queue optimized for constant time push and pop
 * operations of {{type}} elements. It does this by implementing a ring
 * buffer with List's relative indices.
 * authors: @grahamwren, @jagen31
 */
class {{name}}Queue : public Object {
public:
  int _alloc_size;
  {{name}}List *_data;
  int _push_i = 0;
  int _pop_i = 0;

  {{name}}Queue(int size) : _alloc_size(size) {
    _data = new {{name}}List(_alloc_size);
    _alloc_space(_alloc_size);
  }

  {{name}}Queue() : {{name}}Queue(100) {}

  virtual int size() {
    assert(_pop_i <= _push_i);
    return _push_i - _pop_i;
  }

  virtual bool empty() {
    return _push_i == _pop_i;
  }

  virtual void push({{type}} e) {
    if (size() + 1 > _alloc_size)
      _alloc_space(_alloc_size * 2);

    _data->set(_push_i++, e); // set at, then increment our push_i
  }

  virtual {{type}} &pop() {
    assert(size() > 0);
    return _data->get(_pop_i++); // get at, then increment our pop_i
  }

  /**
   * peek a value in the queue. Index argument is the distance from being
   * returned by pop. e.g. 0 is the next element to be popped and size() - 1 is
   * the most recently added element
   */
  virtual {{type}} &peek(int idx) {
    assert(0 <= idx);
    assert(idx < size());
    return _data->get(_pop_i + idx);
  }

  void _alloc_space(int req_size) {
    int current_len = size();
    // must have at least enough space to hold current elements and have an
    // element to push into
    assert(req_size > current_len);

    {{type}} *temp = new {{type}}[current_len];
    for (int i = 0; i < current_len; i++) {
      // copy into temp starting at _pop_i and going to length
      temp[i] = _data->get(_pop_i + i);
    }
    _data->ensure_space(req_size);
    for (int i = 0; i < req_size; i++) {
      // if in length, get element to be pushed out of temp, otherwise NULL
      {{type}} e = i < current_len ? temp[i] : ({{type}})NULL;
      if (i < _data->size()) {
        _data->set(i, e); // if within size, set
      } else {
        _data->push(e);   // else, push
      }
    }
    delete[] temp;

    _pop_i = 0;             // reset pop_i to start of _data
    _push_i = current_len;  // reset push_i to current_len
    _alloc_size = req_size; // set alloc_size to new size
  }
};
