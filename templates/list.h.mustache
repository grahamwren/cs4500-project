#pragma once

// lang::CwC

#include "../lib.h"

/**
 * {{name}}List: a dynamically scaling list of {{type}} elements
 * authors: @grahamwren, @jagen31
 */
class {{name}}List : public Object {
public:
  int _initial_size = 0;
  int _allocated_size = 0;
  int _size = 0;
  {{type}} *_data = nullptr; // OWNED

  {{name}}List(int initial_size) : _initial_size(initial_size) {
    ensure_space(initial_size);
  }
  {{name}}List(const {{name}}List &other) : {{name}}List(other.size()) {
    for (int i = 0; i < other.size(); i++) {
      push(other.get(i));
    }
  }
  {{name}}List({{name}}List &&other)
    : _initial_size(other._initial_size),
      _allocated_size(other._allocated_size),
      _size(other._size), _data(other._data) {
    other._data = nullptr;
  }
  {{name}}List() : {{name}}List(3) {}
  virtual ~{{name}}List() { delete[] _data; }
  virtual int size() const { return _size; }

  /**
   * push: append an element to list.
   *
   * @effect removes value at new size(), decreases size() by 1
   */
  virtual void push({{type}} e) {
    ensure_space(_size + 1); // ensure space for one more val
    hash_ = 0;               // reset cached hash
    _size++;                 // increase the length
    set(-1, e);              // set last element to e
  }

  /**
   * pop: remove last element from list
   *
   * @effect adds value at old size(), increases size() by 1
   */
  virtual {{type}} pop() {
    assert(_size > 0);    // at least one element in list
    hash_ = 0;            // reset cached hash
    {{type}} e = get(-1); // get last element
    _size--;              // decrement _size
    return e;
  }

  /**
   * get: get the element at the requested index
   */
  virtual {{type}} &get(int rel_i) const {
    assert(_size > 0);                   // cannot get in empty list
    int index = _resolve_index(rel_i);   // resolve relative index
    assert(0 <= index && index < _size); // assert index is valid TODO: (@grahamwren) remove assert once trust resolve_index
    return _data[index];
  }

  /**
   * set: replace the element at i with e then return the replaced element, if
   *      requested index is outside the current list, assumes index is
   *      relative to length of the list.
   * @effect mutates this, size() unchanged
   */
  virtual {{type}} set(int rel_i, {{type}} e) {
    assert(_size > 0);                   // cannot set in empty list
    int index = _resolve_index(rel_i);   // resolve relative index
    assert(0 <= index && index < _size); // assert index is valid TODO: (@grahamwren) remove assert once trust resolve_index
    hash_ = 0;                           // mutates this so reset cached hash
    {{type}} old = get(index);           // get element being replaced
    _data[index] = e;                    // set index to e
    return old;                          // return old element
  }

  /**
   * move: move n elements from the from_i index to the to_i index
   *
   * @effect moves n elements from rel_from_i to rel_to_i, size() unchanged
   */
  virtual void move(int n, int rel_from_i, int rel_to_i) {
    int from_i = _resolve_index(rel_from_i);
    int to_i = _resolve_index(rel_to_i);

    // assert this is a valid move within the list
    assert(from_i + n <= _size && to_i + n <= _size);

    // return if nothing to do
    if (from_i == to_i)
      return;

    // something to do, reset hash
    hash_ = 0; // reset cached hash

    // copy chunk to be moved into temp array
    {{type}} *temp = new {{type}}[n];
    for (int i = 0; i < n; i++) {
      temp[i] = get(from_i + i);
    }

    if (from_i < to_i) { // moving right
      // copy all _data starting after `from_i + n` until `to_i + n` into
      // `from_i`
      _copy(from_i + n, to_i + n, from_i);
    } else { // moving left
      // copy all _data starting at `to_i` until `from_i + n` into `to_i + n`
      _copy(to_i, from_i + n, to_i + n);
    }

    // copy temp into `to_i`
    for (int i = 0; i < n; i++) {
      set(to_i + i, temp[i]);
    }

    // free temp
    delete[] temp;
  }

  void _copy(int start, int end, int dest) {
    int chunk_len = end - start;
    {{type}} *chunk = new {{type}}[chunk_len];
    for (int i = 0; i < chunk_len; i++) {
      chunk[i] = get(start + i);
    }
    for (int i = 0; i < chunk_len; i++) {
      if (dest + i >= size())
        continue;
      set(dest + i, chunk[i]);
    }
    delete[] chunk;
  }

  /**
   * swaps one element with another
   *
   * @effect swaps elements, size() unchanged
   */
  virtual void swap(int rel_from_i, int rel_to_i) {
    hash_ = 0;                      // reset hash because mutation
    {{type}} e = get(rel_to_i);     // get dest element
    set(rel_to_i, get(rel_from_i)); // set src element at dest position
    set(rel_from_i, e);             // set dest element at src position
  }

  /**
   * find: return the index of the first occurance of the element
   *       which is `==` to the given object. If not found
   *       returns `size() + 1`
   */
  virtual int find({{type}} o) {
    int len = size();
    for (int i = 0; i < len; i++) {
      {{type}} e = get(i);
      if (o == e)
        return i;
    }
    return len + 1;
  };

  /**
   * clear: empties the list
   *
   * @effect size() = 0
   */
  virtual void clear() {
    _size = 0;                  // reset size
    hash_ = 0;                  // reset cached hash
    _alloc_data(_initial_size); // re-allocate empty data (unnecessary)
  }

  /**
   * ensure_space: ensure there is space for the requested size, if not
   *               allocate more. This method is designed for when a user of
   *               this List wants to push multiple elements without triggering
   *               re-allocates. This will allocate the requested space ahead
   *               of time.
   *
   * @effect pre-allocates the requested amount of space all-at-once, size()
   *         unchanged
   */
  virtual void ensure_space(int requested_size) {
    if (requested_size == 0) return; // do NOT allocate if requesting zero space
    if (requested_size > _allocated_size) {
      // allocate ~50% more space than requested
      int alloc_size = (fmax(requested_size, 2) / 2) * 3;
      _alloc_data(alloc_size);
    }
  }

  void _alloc_data(int alloc_size) {
    {{type}} *old = _data;
    _data = new {{type}}[alloc_size];
    _allocated_size = alloc_size;

    if (old != nullptr) {
      for (int i = 0; i < _size; i++) {
        _data[i] = old[i];
      }
      delete[] old;
    }
  }

  int _resolve_index(int i) const {
    int len = size();
    int index = i % len;
    if (index >= 0) // if positive just return it
      return index;
    return len + index; // else negative, treat as dist from end
  }

  virtual void _debug_name() { p("{{name}}List"); }
  virtual void _debug_meta() {};
  virtual void debug() {
    int len = size();
    _debug_name();
    p("<").p((void*)this).p(">(size: ").p(len).p(", ");
    _debug_meta();
    p("entries: [");
    if (len > 0) {
      p(get(0));
      for (int i = 1; i < len; i++) {
        p(", ").p(get(i));
      }
    }
    pln("])");
  }

  // impl Object

  bool equals(Object *o) {
    {{name}}List *other = dynamic_cast<{{name}}List *>(o);
    if (other == nullptr || other->size() != size())
      return false;

    bool eq = true;
    int len = size();
    for (int i = 0; i < len; i++) {
      eq = eq && get(i) == other->get(i);
    }
    return eq;
  }

  Object *clone() {
    int len = size();
    {{name}}List *result = new {{name}}List(len);
    for (int i = 0; i < len; i++) {
      result->push(get(i));
    }
    return result;
  }

  size_t hash_me() {
    size_t hash = 0;
    int len = size();
    for (int i = 0; i < len; i++) {
      hash = (hash << 4) ^ (size_t)get(i);
    }
    return hash;
  }
};

class {{name}}ListIter : public Object {
public:
  int index = 0;
  {{name}}List &_list;

  {{name}}ListIter({{name}}List &list, int start) : index(start), _list(list) {}
  {{name}}ListIter({{name}}List &list) : {{name}}ListIter(list, 0) {}

  bool empty() { return index == _list.size(); }

  {{type}} next() { return _list.get(index++); }

  {{type}} peek() { return _list.get(index); }
};

